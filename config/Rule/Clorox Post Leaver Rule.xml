<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="Clorox Post Leaver Rule">
  <Description>This rule runs after the leaver is completed.</Description>
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule"  name="Clorox Approval Library"/>
  </ReferencedRules>
  <Source>
  <![CDATA[
  import sailpoint.object.Custom;
  import sailpoint.object.Identity;
  import sailpoint.services.ServicesUtil;
  import sailpoint.object.RequestDefinition;
  import sailpoint.object.Request;
  import sailpoint.object.Filter;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Link;
  import sailpoint.object.Application;
  import sailpoint.api.IdentityService;
  import java.text.SimpleDateFormat;
  import java.text.DateFormat;
  import java.util.Date;
  import java.util.Calendar;
  import sailpoint.object.Bundle;
  import sailpoint.object.Identity;
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.api.Provisioner;
  import sailpoint.api.SailPointContext;
  import sailpoint.tools.GeneralException;
  import java.util.ArrayList;
  import java.util.List;

  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level;

  //Log logger1 = LogFactory.getLog("clorox.extension.rule.postLeaver");

  if(identityName != null)
  {
    Identity identity = context.getObjectByName(Identity.class, identityName);

    if(identity != null)
    {
      //get object that has the badging locations
      Custom badgingLocations = context.getObjectByName(Custom.class, "Clorox Badging Location Email Mappings");

      if(badgingLocations != null)
      {
        Map mailargs = new HashMap();

        if(identity != null)
        {
          //get user location
          String location = identity.getAttribute("location");

          if(location != null)
          {
            String toEmail = "";

            //remote users all go to the same email address
            if(location.startsWith("Remote -"))
            {
              toEmail = "CLC.Office.Security.Team@clorox.com";
            }
            else
            {
              //otherwise get it from the custom object
              toEmail = badgingLocations.get(location);
            }

            //if no config found for location send it to default address
            if(toEmail == null)
            {
              toEmail = "CLC.Office.Security.Team@clorox.com";
            }

            //send email
            if(toEmail != null)
            {
              mailargs.put("identityName", identityName);
              mailargs.put("event", "leaver");
              mailargs.put("displayName", identity.getDisplayName());
              mailargs.put("location", location);

              if(requestType.equalsIgnoreCase("IMMEDIATE TERMINATION FEATURE"))
              {
                ServicesUtil.sendEmailMessage(context, toEmail, "Clorox Badging Location EmergencyTermination EmailTemplate", mailargs);
              }
              else
              {
                ServicesUtil.sendEmailMessage(context, toEmail, "Clorox Badging Location Leaver EmailTemplate", mailargs);
              }
            }
            else
            {
              //logger.warn("Not sending desktop support email as no to email was found");
            }
          }
          else
          {
            //logger1.warn("Not sending desktop support email as no location was found");
          }
        }

      }

      Filter filter = Filter.and(Filter.eq("identity.id", identity.getId()), Filter.eq("application.type", "Logical"));
      Iterator search = context.search(Link.class, new QueryOptions().addFilter(filter), "id");
      while(search.hasNext()) {
        Link link = context.getObjectById(Link.class, (String)search.next()[0]);
        link.setAttribute("IIQDisabled", true);
        context.saveObject(link);
      }
      context.commitTransaction();

      //set the saccountownerOne
      //does user have an active directory account?
      Filter serviceCube = Filter.eq("serviceCube","TRUE");					
      Filter owner = Filter.eq("saccountOwnerone",identity.getName());

      QueryOptions option = new QueryOptions();
      option.addFilter(serviceCube);
      option.addFilter(owner);

      Iterator iterator = context.search(Identity.class,option);

      Identity newOwner = identity.getManager();

      if(iterator != null)
      {
        while(iterator.hasNext())
        {
          Identity ids = (Identity) iterator.next();
          if(ids != null && newOwner != null)
          {
            ids.setAttribute("saccountOwnerone",newOwner.getName());
            context.saveObject(ids);
            context.commitTransaction();          
            RequestDefinition reqDef = context.getObjectByName(RequestDefinition.class, "Workflow Request");
            Request request = new Request(reqDef); 
            String requestName = "Launch Attribute Sync After Leaver: " + ids.getName();
            request.setName(requestName);
            request.setAttribute("workflow", "Workflow-Lifecycle-AttributeSync");
            request.setAttribute("identityName", ids.getName());
            request.setAttribute("launcher", "spadmin");
            request.setNextLaunch(new Date());
            context.saveObject(request);
            context.commitTransaction();
          }
        }
      }	

      // check the termination date with leaver launched date

      SimpleDateFormat df = new SimpleDateFormat("MM/dd/yyyy");
      df.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));

      Date termDate = identity.getAttribute("terminationDate");
      Date ctrexpDate = identity.getAttribute("ctrexpDt");

      if(ctrexpDate != null && termDate != null)
      {		
        ctrexpDate =  df.parse(df.format(ctrexpDate));  
        termDate = df.parse(df.format(termDate));

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(ctrexpDate);
        calendar.add(Calendar.DATE, +1);

        ctrexpDate = calendar.getTime();

        if(ctrexpDate.compareTo(termDate) < 0)
        {
          //send email to HR
          Map mailargs = new HashMap();

          if(identity != null)
          {
            String toEmail = "HR.Workday.Administration@clorox.com";
            mailargs.put("identityName", identityName);
            mailargs.put("firstname", identity.getFirstname());
            mailargs.put("lastname", identity.getLastname());
            mailargs.put("terminationDate", identity.getAttribute("terminationDate"));

            ServicesUtil.sendEmailMessage(context, toEmail, "Clorox Termination Mismatch Email", mailargs);
          }

        }
      }

    }
  }
  ]]></Source>
</Rule>
